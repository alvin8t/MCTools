"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.log = exports.Logger = exports.PADDING = exports.debug = undefined;
exports.setPrinter = setPrinter;

var _chalk;

function _load_chalk() {
    return _chalk = _interopRequireDefault(require("chalk"));
}

var _debug2 = _interopRequireDefault(require("debug"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

let printer = null;
const debug = exports.debug = (0, _debug2.default)("electron-builder");
function setPrinter(value) {
    printer = value;
}
const PADDING = exports.PADDING = 3;
class Logger {
    constructor(stream) {
        this.stream = stream;
        this.messageTransformer = it => it;
    }
    filePath(file) {
        const cwd = process.cwd();
        return file.startsWith(cwd) ? file.substring(cwd.length + 1) : file;
    }
    // noinspection JSMethodCanBeStatic
    get isDebugEnabled() {
        return debug.enabled;
    }
    info(messageOrFields, message) {
        this.doLog(message, messageOrFields, "info");
    }
    notice(messageOrFields, message) {
        this.doLog(message, messageOrFields, "notice");
    }
    warn(messageOrFields, message) {
        this.doLog(message, messageOrFields, "warn");
    }
    debug(fields, message) {
        if (debug.enabled) {
            this._doLog(message, fields, "debug");
        }
    }
    doLog(message, messageOrFields, level) {
        if (message === undefined) {
            this._doLog(messageOrFields, null, level);
        } else {
            this._doLog(message, messageOrFields, level);
        }
    }
    _doLog(message, fields, level) {
        const levelIndicator = "â€¢";
        const color = LEVEL_TO_COLOR[level];
        this.stream.write(`${" ".repeat(PADDING)}${color(levelIndicator)} `);
        this.stream.write(Logger.createMessage(this.messageTransformer(message, level), fields, level, color));
        this.stream.write("\n");
    }
    static createMessage(message, fields, level, color) {
        let text = message;
        const fieldPadding = " ".repeat(Math.max(0, 16 - message.length));
        text += fieldPadding;
        if (fields != null) {
            for (const name of Object.keys(fields)) {
                let fieldValue = fields[name];
                if (fieldValue != null && typeof fieldValue === "string" && fieldValue.includes("\n")) {
                    fieldValue = ("\n" + fieldValue).replace(/\n/g, `\n${" ".repeat(PADDING)}${fieldPadding}`);
                }
                text += ` ${color(name)}=${Array.isArray(fieldValue) ? JSON.stringify(fieldValue) : fieldValue}`;
            }
        }
        return text;
    }
    log(message) {
        if (printer == null) {
            this.stream.write(`${message}\n`);
        } else {
            printer(message);
        }
    }
}
exports.Logger = Logger;
const LEVEL_TO_COLOR = {
    info: (_chalk || _load_chalk()).default.blue,
    notice: (_chalk || _load_chalk()).default.yellow,
    warn: (_chalk || _load_chalk()).default.yellow,
    debug: (_chalk || _load_chalk()).default.gray
};
const log = exports.log = new Logger(process.stdout);
//# sourceMappingURL=log.js.map